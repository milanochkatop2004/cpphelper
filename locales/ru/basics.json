{
	"id": "basics",
	"name": "<b>Базовые концепты</b>",
	"overview": "В этой секции разъясняются концепты, необходимыя для понимания языка <b>C++.</b>",

	"data_types": 
	{
		"name": "Типы данных",
		"page_1": 
		[
			"Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно выполнять и сколько байтов в памяти она будет занимать. Следующие основные типы данных определены в <b>C++</b>:",
			"<b>bool:</b> логический тип. Может принимать одно из двух значений - _ True_ и _False_. Размер занимаемой памяти для этого типа точно не определен.",
			"<b>char:</b> представляет собой один символ ASCII. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «-128» до «127» или от «0» до «255».",
			"<b>signed char:</b> представляет один символ. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «-128» до «127».",
			"<b>unsigned char:</b> представляет один символ. Он занимает в памяти 1 байт (8 бит). Может хранить любое значение от «0» до «255».",
			"<b>wchar_t:</b> представляет собой широкий персонаж. В Windows он занимает в памяти 2 байта (16 бит), в Linux - 4 байта (32 бита). Может хранить любое значение от 0 до 65 535 (для 2 байтов) или от 0 до 4 294 967 295 (для 4 байтов).",
			"<b>char16_t:</b> представляет один символ Юникода. Он занимает в памяти 2 байта (16 бит). Может хранить любое значение от «0» до «65535»."

		],
		
		"page_2":
		[
			"<b>char32_t:</b> представляет один символ Юникода. Он занимает 4 байта (32 бита) в памяти. Может хранить любое значение от 0 до 4 294 967 295.",
			"<b>short:</b> представляет собой целое число в диапазоне от –32768 до 32767. Занимает 2 байта (16 бит) в памяти.",
			"<b>unsigned short:</b> представляет собой целое число в диапазоне от 0 до 65 535. Занимает 2 байта (16 бит) в памяти.",
			"<b>int:</b> представляет собой целое число. В зависимости от архитектуры процессора он может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений, соответственно, также может варьируются от -32768 до 32767 (для 2 байтов) или от -2 147 483 648 до 2 147 483 647 (для 4 байтов). Но в любом случае размер должен быть больше или равен размеру короткого типа и меньше или равен размер длинного типа. Этот тип является синонимом <b> signed int </b> и <b> signed </b>.",
			"<b>unsigned int:</b> представляет собой положительное целое число. Оно может занимать 2 байта (16 бит) или 4 байта (32 бита) в зависимости от архитектуры процессора, и поэтому диапазон предельных значений может варьируются: от 0 до 65535 (для 2 байтов) или от 0 до 4 294 967 295 (для 4 байтов). В качестве синонима этого типа может использоваться <b> беззнаковый </b>.",
			"<b>long:</b> представляет целое число от -2 147 483 648 до 2 147 483 647. Он занимает 4 байта (32 бита) памяти. Этот тип также имеет синонимы для <b> long int </b>, <b> подписанное длинное целое </b> и <b> длинное подписанное </b>."
			
		],
		
		"page_3":
		[
			"<b>unsigned long:</b> представляет собой целое число от 0 до 4 294 967 295. Занимает 4 байта (32 бита) памяти. Это синоним <b> unsigned long int </b>.",
			"<b>long long:</b> представляет собой целое число в диапазоне от -9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Обычно занимает 8 байтов (64 бита) памяти. Синонимы: < b> long long int </b>, <b> signed long long int </b> и <b> signed long long </b>. ",
			"<b>unsigned long long:</b> представляет собой целое число от 0 до 18 446 744 073 709 551 615. Обычно занимает 8 байтов (64 бита) памяти. Это синоним <b> unsigned long long int </b>.",
			"<b>float:</b> представляет собой вещественное число с плавающей запятой в диапазоне от +/- 3,4E-38 до 3,4E + 38. Занимает 4 байта (32 бита) в памяти.",
			"<b>double:</b> представляет действительное число с плавающей запятой двойной точности в диапазоне от +/- 1,7E-308 до 1,7E + 308. Оно занимает 8 байтов (64 бита) в памяти.",
			"<b>long double:</b> представляет действительное число с плавающей запятой двойной точности размером не менее 8 байтов (64 бита). Диапазон допустимых значений может отличаться в зависимости от размера занимаемой памяти.",
			"<b>void:</b> тип без значения.",
			"Таким образом, все типы данных, кроме void, можно разделить на три группы: символьные (char, wchar_t, char16_t, char32_t), целые (short, int, long, long long) и типы чисел с плавающей запятой (float, double, long double )."
		],
		
		"page_4":
		[
			"<b>Символьные типы</b>",
			"Для представления символов в приложении используются типы char, wchar_t, char16_t и char32_t. Определим несколько переменных: \n 1. <code>char c = d;</code> \n 2. <code>wchar_t d = c;</code> \n",
			"Переменная типа char в качестве значения принимает один символ в одинарных кавычках: char c ='d'. Также можно присвоить число из указанного выше в списке диапазона: char c = 120. В этом случае значением переменной c будет тот символ, который имеет код 120 в таблице символов ASCII.",
			"Стоит учитывать, что для вывода на консоль символов wchar_t следует использовать не std::cout, а поток <b>std::wcout</b>",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { /n 4. char a = 'H'; \n 5. wchar_t b ='e'; \n 6. std::wcout&lt;&lt;a&lt;&lt;b&lt;&lt;'/n'; \n 7. return 0; \n 8. }",
			"При этом поток std::wcout может работать как с char, так и с wchar_t. А поток std::cout для переменной wchar_t вместо символа будет выводить его числовой код.",
			"В стандарте С++11 были добавлены типы <b>char16_t</b> и <b>char32_t</b>, которые ориентированы на использование Unicode. Однако на уровне ОС пока не реализованы потоки для работы с этими типами. Поэтому если потребуется вывести на консоль значения переменных этих типов, то необходимо преобразовать переменные к типам char или wchar_t:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { /n 4. char a = 'H'; \n 5. wchar_t b = 'e'; \n 6. char16_t c = 'l'; \n 7. char32_t d = 'o'; \n 8. std::cout&lt;&lt;a&lt;&lt;(char)b&lt;&lt;(char)c&lt;&lt;(char)d&lt;&lt;'/n'; \n 9. return 0; \n 10. }",
			"В данном случае при выводе перед переменными указывается операция приведения к типу char - <b>(char)</b>, благодаря чему значения переменных b, c и d преобразуются в тип char и могут быть выведены на консоль с помощью потока std::cout."
		],
		
		"page_5":
		[
			"<b>Целочисленные типы</b>;",
			"Целочисленные типы представлены следующими типами: <b>short, unsigned short, int, unsigned int, long, unsigned long, long long and unsigned long long:</b>",
			"1. <b>short</b> a = -10; \n 2. unsigned <b>short</b> b = 10; \n 3. <b>int</b> c = -30; \n 4. unsigned <b>int</b> d = 60; \n 5. <b>long</b> e = -170; \n 6. unsigned <b>long</b> f = 45; \n 7. <b>long long</b> g = 89;"
		],
		
		"page_6":
		[
			"<b>Типы чисел с плавающей точкой</b>",
			"Типы чисел с плавающей точкой или дробные числа представлены такими типами как <b>float, double</b>, и <b>long double:</b>",
			"1. <b>float</b> a = -10.45; \n 2. <b>double</b> b = 0.00105; \n 3. <b>long double</b> c = 30.890045;"
		],
		
		"page_7":
		[
			"<b>Размеры типов данных</b>",
			"В выше приведенном списке для каждого типа указан размер, который он занимает в памяти. Однако стоит отметить, что предельные размеры для типов разработчики компиляторов могут выбирать самостоятельно, исходя из аппаратных возможностей компьютера. Стандарт устанавливает лишь минимальные значения, которые должны быть. Например, для типов int и short минимальное значение - 16 бит, для типа long - 32 бита, для типа long double. При этом размер типа long должен быть не меньше размера типа int, а размер типа int - не меньше размера типа short, а размер типа long double должен быть больше double. К примеру, компилятор g++ под Windows для long double использует 12 байт, а компилятор, встроенный в Visual Studio и также работающий под Windows, для long double использует 8 байт. То есть даже в рамках одной платформы разные компиляторы могут по разному подходить к размерам некоторых типов данных. Но в целом используются те размеры, которые указаны выше при описании типов данных.",
			"Однако бывают ситуации, когда необходимо точно знать размер определенного типа. И для этого в С++ есть оператор <b>sizeof()</b>, который возвращает размер памяти в байтах, которую занимает переменная:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. <b>long double</b> number = 2; \n 5. std::cout&lt;&lt;'sizeof(number)='&lt;&lt;sizeof(number); \n 6. return 0; \n 7. }",
			"Консольный вывод при компиляции в g++:",
			"<b>sizeof(number) = 12</b>",
			"При этом при определении переменных важно понимать, что значение переменной не должно выходить за те пределы, которые очерчены для ее типа. Например:",
			"1. unsigned <b>short</b> number = -65535;",
			"Компиляция такого кода может пройти без ошибок, хотя некоторые компиляторы, как G++ могут выдавать предупреждения о том, что значение будет усечено. Однако при комиляции переменная number получит значение 1 - результат преобразования числа -65535 к типу unsigned short. То есть опять же результат будет не совсем тот, который ожидается. Значение переменной - это всего лишь набор битов в памяти, которые интерпретируются в соответствии с определенным типом. И для разных типов один и тот же набор битов может интерпретироваться по разному. Поэтому важно учитывать диапазоны значений для того или иного типа при присвоении переменной значения."
		],
		
		"page_8":
		[
			"<b>Спецификатор auto</b>",
			"Иногда бывает трудно определить тип выражения. И согласно последним стандартам можно предоставить компилятору самому выводить тип объекта. И для этого применяется спецификатор auto. При этом если мы определяем переменную со спецификатором <b>auto</b>, эта переменная должна быть обязательно инициализирована каким-либо значением:",
			"1. auto number = 5;",
			"На основании присвоенного значения компилятор выведет тип переменной. Неинициализированные переменные со спецификатором auto не допускаются:",
			"1. auto number;"
		]
	},
	
	"variables": 
	{
		"name": "Переменные",
		"page_1":
		[
			"Как и во многих языках программирования, в C++ для хранения данных используются <b>переменные</b>. Переменная имеет тип, имя и значение. Тип определяет, какую информацию может хранить переменная.",
			"Перед использованием любую переменную надо определить. Синтаксис определения переменной выглядит следующим образом:",
			"1. тип_переменной имя_переменной;",
			"Простейшее определение переменной: \n 1. int age; \n ",
			"Здесь определена переменная age, которая имеет тип <b>int</b>. Поскольку определение переменной представляет собой инструкцию, то после него ставится точка с запятой.",
			"Также стоит учитывать, что C++ - регистрозависимый язык, а это значит, что регистр символов имеет большое значение. То есть в следующем коде будут определяться две разные переменные:",
			"1. int age;",
			"2. int age;",
			"Подобное определение вызовет ошибку на этапе компиляции.",
			"И в довершеие следует сказать, что переменным стоит давать осмысленные имена, которые будут говорить об их предназначении."
		],
		
		"page_2":
		[
			"<b>Инициализация</b>",
			"После определения переменной можно присвоить некоторое значение:",
			"1. int age;",
			"2. age = 20;",
			"Например, определим в прогамме переменную и выведем ее значение на консоль: \n 1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. int age; \n 5. age=28; \n 6. std::cout&lt;&lt;'Age='&lt;&lt;age; \n 7. return 0; \n 8. }",
			"С помощью последовательности операторов <b>&lt;&lt;</b> можно вывести несколько значений на консоль.",
			"После компиляции и запуска скомпилированной программы на консоль будет выведено число 28.",
			"Однако также можно сразу при определении переменной дать ей некоторое начальное значение. Данный прием называется <b>инициализацией</b>, то есть присвоение переменной начального значения:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. int age = 28; \n 5. std::cout&lt;&lt;'Age ='&lt;&lt;age; \n 6. return 0; \n 7. }"
		],
		
		"page_3":
		[
			"<b>Инициализация по умолчанию</b>",
			"Если переменную не инициализировать, то происходит ее инициализация по умолчанию. И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.",
			"Если переменная, которая представляет встроенный тип (например, тип int), определена внутри функции, то она получает неопределенное значение. Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число 0. Например:",
			"1. #include &lt;iostream&gt; \n 2. int x; \n 3. int main() \n 4. { \n 5. int y; \n 6. std::cout&lt;&lt;'X='&lt;&lt;x&lt;&lt;'\n'; \n 7. std::cout&lt;&lt;'Y='&lt;&lt;y; \n 8. return 0; \n 9. }",
			"Переменная x определена вне функции, и поэтому она получит значение по умолчанию - число 0.",
			"Гораздо сложнее дело обстоит с переменной y, которая определена внутри функции main - ее значение будет неопределенным, и многое будет зависеть от используемого компилятора. В частности, вывод программы, скомпилированной с помощью компилятора G++, может выглядеть следующим образом:",
			"<b>x=0</b> \n <b>y=4200475</b>",
			"А в Visual Studio отсутствие значения переменной y вызовет ошибку.",
			"Но в любом случае перед использованием переменной лучше явным образом назначать ей определенное значение, а не полагаться на значение по умолчанию."
		],
		
		"page_4":
		[
			"<b>Изменение значения</b>",
			"Ключевой особенностью переменных является то, что мы можем изменять их значения:",
			"1. #include &lt;iostream&gt; \n 2. int main() \n 3. { \n 4. int x = 6; \n 5. x = 8; \n 6. x = 10; \n 7. std::cout&lt;&lt;'X='&lt;&lt;x; // X=10 \n 8. return 0; \n 9. }"
		]
	},
	"arithmetical_operations": 
	{
		"name": "<b>Арифметические операции</b>",
		"page_1":
		[
			"Арифметические операции производятся над числами. Значения, которые участвуют в операции, называются операндами. В языке программирования C++ арифметические операции бинарными (производятся над двумя операндами) и унарными (выполняются над одним операндом). К бинарным операциям относят следующие:",
			"<b>+</b>",
			"Операция сложения возвращает сумму двух чисел: \nint a = 10; \nint b = 7; \nint c = a + b; //17 \nint d = 4 + b; //11",
			"<b>-</b>",
			"Операция вычитания возвращает разность двух чисел: \nint a = 10; \nint b = 7; \nint c = a - b; //3 \nint d = 41 - b; //34",
			"<b>*</b>",
			"Операция умножения возвращает произведение двух чисел: \nint a = 10; \nint b = 7; \nint c = a * b; //70 \nint d = b * 5; //35",
			"<b>/</b>",
			"Операция деления возвращает частное двух чисел: \nint a = 20; \nint b = 5; \nint c = a / b; //4 \ndouble d = 22.5 * 4.5; //5 \nПри делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float или double:",
			"<b>double</b> k = 10 / 4; //2 \nstd::cout&lt;&lt;k; \nЧтобы результат представлял числос плавающей точкой, один из операндов также должен представлять число с плавающей точкой: \n<b>double</b> k = 10.0 / 4 //2.5 \nstd::cout&lt;&lt;k;",
			"<b>%</b>",
			"Операция получения остатка от целочисленного деления: \nint a = 33; \nint b = 5; \nint c = a % b; //3 \nint d = 22 % 4 //2 (22-4*5=2)",
			"Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:"
		],
		
		"page_2":
		[
			"<b>Префиксный инкремент</b>",
			"Увеличивает значение переменной на единицу и полученный результат используется как значение выражения ++x \nint a = 8; \nint b = ++a; \nstd::cout&lt;&lt;a,<'\n'; //9 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //9",
			"<b>Постфиксный инкремент</b>",
			"Увеличивает значение переменной на единицу, но значением выражения x++ будет то, которое было до увеличения на единицу --x \nint a = 8; \nint b = a++; \nstd::cout&lt;&lt;a,<'\n'; //9 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //8",
			"<b>Префиксный декремент</b>",
			"Уменьшает значение переменной на единицу, и полученное значение используется как значение выражения --x \nint a = 8; \nint b = --a; \nstd::cout&lt;&lt;a,<'\n'; //7 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //7",
			"<b>Постфиксный декремент.</b>",
			"Уменьшает значение переменной на единицу, но значением выражения x-- будет то, которое было до уменьшения на единицу \nint a = 8; \nint b = a--; \nstd::cout&lt;&lt;a,<'\n'; //7 \nstd::cout&lt;&lt;b&lt;&lt;'\n'; //8",
			"Арифметические операции вычисляются слева направо. Одни операции имеют больший приоритет чем другие и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:\n+ (инкремент), - (декремент) \n* (умножение), / (деление), % (остаток от деления) \n+ (сложение), - (вычитание)",
			"Приоритет операций следует учитывать при выполнении набора арифметических выражений: \nint a = 8; \nint b = 7; \nint c = a + 5 * ++b; //48 \nstd::cout&lt;&lt;c; \nХотя операции выполняются слева направо, но вначале будет выполняться операция инкремента ++b, которая увеличит значение переменной b и возвратит его в качестве результата, так как эта операция имеет больший приоритет. Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b",
			"Скобки позволяют переопределить порядок вычислений. Например: \nint a = 8; \nint b = 7; \nint c = (a + 5) * ++b; //104 \nstd::cout&lt;&lt;c; \nНесмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки."
		]
		
	
	},
	
	"static_typization": 
	{
		"name": "Статическая типизация",
		"page_1":
		[
			"С++ является статически типизированным языком программирования. То есть если мы определили для переменной какой-то тип данных, то в последующем мы этот тип изменить не сможем. Соответственно переменная может получить значения только того типа, который она представляет. Однако нередко возникает необходимость присвоить переменной значения каких-то других типов. И в этом случае применяются преобразования типов.",
			"Ряд преобразований компилятор может производить неявно, то есть автоматически. Например:",
			"1. #include &lt;iostream&gt; \nint main() \n{ \nint code = 'g'; \nchar letter = 103; \nstd::cout&lt;&lt;letter&lt;&lt;'in ASCII is'&lt;&lt;code&lt;&lt;'\n'; \nreturn 0; \n}",
			"В данном случае числовой переменной типа int присваивается символ 'g'. Этот символ будет автоматически преобразовываться в число. По факту переменная получит числовой код этого символа в таблице ASCII.",
			"Переменной letter, наоборот, присваивается число, хотя эта переменная представляет тип char. Это число будет преобразовываться в символ, и в итоге переменная letter будет хранить символ, чей код в таблице ASCII равен 103, то есть символ 'g'.",
			"Результатом этой программы будет следующий консольный вывод: \n<b>g in ASCII is 103</b> \nКак выполняются преобразования:",
			"Переменной типа <b>bool</b> присваивается значение другого типа. В этом случае переменная получает <b>false</b>, если значение равно 0. Во всех остальных случаях переменная получает <b>true</b>. \nbool a = 1; //true \nbool b = 0 //false \nbool c='g'; //true \nbool d = 3.4 //true",
			"Числовой или символьной переменной присваивается значение типа <b>bool</b>. В этом случае переменная получает 1, если значений равно <b>true</b>, либо получает 0, если присваиваемое значение равно <b>false</b>. \nint c = true; //1 \ndouble d = false; //0",
			"Целочисленной переменной присваивается дробное число. В этом случае дробная часть после запятой отбрасывается \nint a = 3.4 //3 \nint b = 3.6 //3",
			"Переменной, которая представляет тип с плавающей точкой, присваивается целое число. В этом случае если целое число содержит больше битов, чем может вместить тип переменной, то часть информации усекается. \nfloat a = 35005; //35005 \ndouble b = 3500500000033; //3.5005e+012",
			"Переменной беззнакового типа (unsigned) присваивается значение не из его диапазона. В этом случае результатом будет остаток от деления по модулю. Например, тип unsigned char может хранить значения от 0 до 255. Если присвоить ему значение вне этого диапазона, то компилятор присвоит ему остаток от деления по модулю 256 (так как тип unsigned char может хранить 256 значений). Так, при присвоении значения -1 переменная типа unsigned char получит 256 - |-1/256| = 255",
			"1. unsigned char a = -5; //251 \nunsigned short b = -3500; //62036 () \nunsigned int c = -5000000000; //4244967296 \nПеременной знакового типа (signed) присваивается значение не из его диапазона. В этом случае результат не определен. Программа может работать нормально, выдавая адекватный результат, а может работать некорректно."
		],
		
		"page_2":
		[
			"<b>Опасные и безопасные преобразования</b>",
			"Те преобразования, при которых не происходит потеря информации, являются безопасными. Как правило, это преобразования от типа с меньшей разрядностью к типу с большей разрядностью. В частности, это следующие цепочки преобразований:",
			"<b>bool -> char -> short -> int -> double -> long double</b> \n<b>bool -> char -> short -> int -> long -> long long</b> \n<b>unsigned char -> unsigned short -> unsigned int -> unsigned long</b> \n<b>float -> double -> long double</b>",
			"Примеры безопасных преобразований:\nshort a = 'g'; //преобразование из char в short \nint b = 10; \ndouble c = b; //преобразование из int в double \nfloat d = 3.4 \ndouble e = d //преобразование из float в double \ndouble f =35; //преобразование из int в double",
			"Но также есть опасные преобразования. При подобных преобразованиях мы потенциально можем потерять точность данных. Как правило, это преобразования от типа с большей разрядностью к типу с меньшей разрядностью. \nchar letter = 295; \nstd::cout&lt;&lt;letter;",
			"В данном случае переменной letter присваивается значение, которое выходит за пределы диапазона допустимых значений для типа char, то есть больше 255.",
			"И в подобных примерах многое зависит от компилятора. В ряде случаев компиляторы при компиляции выдают предупреждение, тем не менее программа может быть успешно скомпилирована. В других случаях компиляторы не выдают никакого предупреждения. Собственно в этом и заключается опасность, что программа успешно компилируется, но тем не менее существует риск потери точности данных."
			"И, как правило, в подобных случаях при компиляции присваиваемое значение усекается до допустимого. Например, в примере выше число 295 будет сокращено до 39. То есть следующие переменные будут содержать одно и то же значение: \nchar letter1 = 295; \nchar letter2 = 39;"
		]
	},
	
	"constants": 
	{
		"name": "Константы",
		"page_1":
		[
			"Отличительной особенностью переменных является то, что мы можем многократно в течение работы программы изменять их значение: \n<code>int x = 7; \nx = 9; \nx = 5;</code> \nНо кроме переменных в языке программирования C++ можно определять константы. Их значение устанавливается один раз и впоследствии мы его не можем изменить. Константа определяется практически также, как и переменная за тем исключением, что в начале определения константы идет ключевое слово const. Например:",
			"<code>const int x = 22; \nstd::coutt&lt;&lt;x;</code> \nЕсли же мы захотим после определения константы присвоить ей некоторое значение, то компилятор не сможет скомпилировать программу и выведет ошибку: \n<code>const int x = 22; \nx = 78;</code>",
			"То есть такой код не будет работать. И так как нельзя изменить значения константы, то ее всегда необходимо инициализировать, если мы хотим, чтобы она имела некоторое значение. \nЕсли константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать программу, как в следующем случае: \n<code>const int x;</code>",
			"В качестве значения константам можно передавать как обычные литералы, так и динамически вычысляемые значения, например, значения переменных или других констант: \n<code>int a = 10; \nconst int b = 7; \nconst int d = b; \nconst int x = a</code>",
			"Обычно в качестве констант определяются такие значения, которые должны оставаться постоянными в течение работы всей программы и не могут быть изменены. Например, если программы выполняет математические операции с использованием числа PI, то было бы оптимально определить данные значение как константу, так как оно все равно в принципе неизменно: \n<code>const float  pi = 3.14</code>"
		]
	},
	
	"console_io": 
	{
		"name": "Ввод/вывод в консоли",
		"page_1":
		[
			"По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль, эти средства предоставляются библиотекой iostream. В ней определены два типа: <b>istream</b> и <b>ostream</b>. istream представляет поток ввода, а ostream - поток вывода.",
			"Вобще сам темин 'поток' в данном случае представляет последовательность символов, которая записывается на устройство ввода-вывода или считывается с него. И в данном случае под устройством ввода-вывода рассматривается консоль. \nДля записи или вывода символов на консоль применяется объект <b>cout</b>, который представляет тип ostream. А для чтения с консоли используется объект <b>cin</b>. \nДля использования этих объектов в начало исходного файла необходимо подключить библиотеку iostream:",
			"<code>#include &lt;iostream&gt;</code>",
			"<b>Вывод на консоль</b> \nДля вывода на консоль применяется оператор <b>&lt;&lt;</b>. Этот оператор получает два операнда. Левый операнд представляет объект типа ostream, в данном случае объект cout. А правый операнд - значение, которое надо вывести на консоль.",
			"Так как оператор &lt;&lt; возвращает левый операнд - cout, то с помощью цепочки операторов мы можем передать на консоль несколько значений. Например, определим простейшую программу вывода на консоль:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint age = 33; \ndouble weight = 81.23; \nstd::cout &lt;&lt; 'Name:' &lt;&lt; 'Tom' &lt;&lt; '\n'; std::cout << 'Weight:' &lt;&lt; weight &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Консольный вывод программы: \n<b>Name: Tom \nAge: 33 \nWeight: 81.23</b> \nОператору &lt;&lt; передаются различные значения - строки, значения переменных, которые выводятся на консоль.",
			"Строки могут содержать управляющие последовательности, которые интерпретируются определенным образом. Например, последовательность '\n' интерпретируется как перевод на новую строку. Из других управляющих последовательностей также нередко употребляется '\t', которая интерпретируется как табуляция.",
			"Также цепочку операторов &lt;&lt можно завершать значением <b>std::endl</b>, которое вызывает перевод на новую строку и сброс буфера. При выводе в поток данные вначале помещаются в буфер. И сброс буфера гарантирует, что все переданные для вывода на консоль данные немедлено будут выведены на консоль."
		],
		
		"page_2":
		[
			"<b>Ввод с консоли</b>",
			"Для считывания с консоли данных применяется оператор ввода <b>&lt;&lt:</b>, который принимает два операнда. Левый операнд представляет объект типа istream (в данном случае объект cin), с которого производится считывание, а правый операнд - объект, в который считываются данные. \nНапример, считаем данные с консоли:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint age; \ndouble weight; \nstd::cout &lt;&lt; 'Input age:'; \nstd::cin &lt;&lt; age; \nstd::cout &lt;&lt; 'Input weight:'; \nstd::cin &lt;&lt; weight; \nstd::cout &lt;&lt; 'Your age:' &lt;&lt; age &lt;&lt; '\t your weight:' &lt;&lt; weight &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Здесь после приглашений к вводу программа ожидает ввода значений для переменных age и weight. \nПример работы программы: \n<b>Input age: 32 \nInput weight: 67.45 \nYour age: 32	your weight: 67.45</b></code>",
			"Стоит отметить, что так оператор ввода в первом случае будет добавлять данные в целочисленную переменную age, то он ожидает ввода числа. В случае с переменной weight оператор ввода ожидает дробное число, причем разделителем целой и дробной части должна быть точка. Поэтому мы не можем ввести любые значения, например, строки. В этом случае программа может выдать некорректный результат.",
			"Оператор ввода &lt;&lt; возвращает левый операнд - объект cin, поэтому мы можем по цепочке считывать данные в различные переменные: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint age; \ndouble weight; \nstd::cout &lt;&lt; 'Input age:'; \nstd::cin &lt;&lt; age &lt;&lt; weight; \nstd::cout &lt;&lt; 'Your age:' &Lt;&lt; age &lt;&lt; '\t your weight:' &Lt;&lt; weight &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Пример работы программы: \n<b>Input age: 32 67.45 \nYour age: 32	your weight: 67.45</b> \nПосле ввода одного из значений надо будет ввести пробел и затем вводить следующее значение."
		]	
			
	},
	
	"namespaces": 
	{
		"name": "Пространства имён",
		"page_1":
		[
			"При чтении и записи в предыдущих темах использовались объекты std::cout и std::cin соответственно. Причем они использовались с префиксом <b>std::</b>. Этот префикс указывает, что объекты cout, cin, endl определены в пространствен имен <b>std</b>. А само двойное двоеточие :: представляет оператор области видимости (scope operator), который позволяет указать, в каком пространсте имен определен объект. И без префикса эти объекты по умолчанию мы использовать не можем.",
			"Однако подобная запись может показаться несколько громоздкой. И в этом случае можно использовать оператор <b>using</b>, который позволяет ввести в программу объекты из различных пространств имен. \nИспользование оператора using имеет следующй формат: \n<code>using namespace::object</code>",
			"Например, пусть у нас есть следующая программа: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint age; \nstd::cout &lt;&lt; 'Input age:'; \nstd::cin &lt;&lt; age; \nstd::cout &lt;&lt; 'Your age:' &lt;&lt; age &lt;&lt; std::endl; \nreturn 0; \n}</code> \nЗдесь используются сразу три объекта из програнства имен std: cout, cin и endl. Перепишем программу с использованием using:",
			"<code>#include &lt;iostream&gt; \nusing std::cin; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint age; \ncout &lt;&lt; 'Input age:'; \ncin &lt;&lt; age; \ncout &lt;&lt; 'Your age:' &lt;&lt; age &lt;&lt; endl; \nreturn 0; \n}</code>",
			"Для каждого объекта из пространства std определяется свое выражение using. При этом программа будет работать также как и раньше."
		]
	},
			
	"bit_operations": 
	{
		"name": "Побитовые операции",
		"page_1":
		[
			"Побитовые операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над целыми числами. \n<b>Операции сдвига</b> \nКаждое целое число в памяти представлено в виде определенного количества разрядов. И операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево. Операции сдвига применяются только к целочисленным операндам. Есть две операции:",
			"<b>&lt;&lt;</b> \nСдвигает битовое представление числа, представленного первым операндом, влево на определенное количество разрядов, которое задается вторым операндом.",
			"<b>&gt;&gt;</b> \nСдвигает битовое представление числа вправо на определенное количество разрядов. \nПрименение операций: \n<code>int a = 2 &lt;&lt; 2; //10 two digits to the left = 1000 - 8 \nint b = 16 &gt;&gt; 3; //10000 by three digits to the right = 10 - 2",
			"Число 2 в двоичном представлении 10. Если сдвинуть число 10 на два разряда влево, то получится 1000, что в десятичной системе равно число 8. \nЧисло 16 в двоичном представлении 10000. Если сдвинуть число 10 на три разряда вправо (три последних разряда отбрасываются), то получится 10, что в десятичной системе представляет число 2.",
			"<b>Поразрядные операции</b> \nПоразрядные операции также проводятся только над соответствующими разрядами целочисленных операндов: \n<b>&amp:</b> поразрядная конъюнкция (операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1",
			"<b>|:</b> поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1 \n<b>^:</b> поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1",
			"<b>~:</b> поразрядное отрицание или инверсия. Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, а если он равен 0, то он получает значение 1. \nПрименение операций:",
			"<code>int a = 5 | 2 //101 | 010 = 111 - 7 \nint b = 6 &amp 2; // 110 &amp 010 = 10  - 2 \nint c = 5 ^ 2; // 101 ^ 010 = 111 - 7 \nint d = ~9; // -10",
			"Например, выражение 5 | 2 равно 7. Число 5 в двоичной записи равно 101, а число 2 - 10 или 010. Сложим соответствующие разряды обоих чисел. При сложении если хотя бы один разряд равен 1, то сумма обоих разрядов равна 1. Поэтому получаем: \n1 0 1 \n0 1 0 \n1 1 1 \nВ итоге получаем число 111, что в десятичной записи представляет число 7.",
			"Возьмем другое выражение 6 & 2. Число 6 в двоичной записи равно 110, а число 2 - 10 или 010. Умножим соответствующие разряды обоих чисел. Произведение обоих разрядов равно 1, если оба этих разряда равны 1. Иначе произведение равно 0. Поэтому получаем: \n1 1 0 \n0 1 0 \n0 1 0 \nПолучаем число 010, что в десятичной системе равно 2."
		]	
	},
	
	"assignment_operations": 
	{
		"name": "Операции присваивания",
		"page_1":
		[
			"<b>Операции присваивания</b>",
			"Операции присваивания позволяют присвоить некоторое значения. Эти операции выполняются над двумя операндами, причем левый операнд может представлять только модифицируемое именованное выражение, например, переменную.",
			"Базовая операция присваивания = позволяет присвоить значение правого операнда левому операнду: \n<code>int x; \nx=2;</code> \nТо есть в данном случае переменная x (левый операнд) будет иметь значение 2 (правый операнд).",
			"Стоит отметить, что тип значения правого операнда не всегда может совпадать с типом левого операнда. В этом случае компилятор пытается преобразовать значение правого операнда к типу левого операнда. \nПри этом операции присваивания имеют правосторонний порядок, то есть выполняются справа налево. И, таким образом, можно выполнять множественное присваивание:",
			"<code>int  a, b, c; \na = b = c = 34;</code> \nЗдесь сначала вычисляется значение выражения c = 34. Значение правого операнда - 34 присваивается левому операнду с. Далее вычисляется выражение b = c: значение правого операнда c (34) присваивается левому операнду <b>b</b>. И в конце вычисляется выражение a = b: значение правого операнда <b>b</b> (34) присваивается левому операнду <b>a</b>.",
			"Кроме того, следует отметить, что операции присваивания имеют наименьший приоритет по сравнению с другими типами операций, поэтому выполняются в последнюю очередь: \n<code>int x; \nx= 3 + 5;</code> \nВ соответствии с приоритетом операций вначале выполняется выражение 3 + 5, и только потом его значение присваивается переменной x. \nВсе остальные операции присваивания являются сочетанием простой операции присваивания с другими операциями:",
			"<b>+=:</b> присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: <b>A += B</b> эквивалентно <b>A = A + B</b> \n<b>-=:</b> присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: <b>A -= B</b> эквивалентно <b>A = A - B</b>",
			"<b>*=:</b> присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: <b>A *= B</b> эквивалентно <b>A = A * B</b> \n<b>/=:</b> присваивание после деления. Присваивает левому операнду частное левого и правого операндов: <b>A /= B</b> эквивалентно <b>A = A / B</b>",
			"<b>%=:</b> присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: <b>A %= B</b> эквивалентно <b>A = A % B</b> \n<b>&lt;&lt;=:</b> присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: <b>A &lt;&lt;= B</b> эквивалентно<b> A = A &lt;&lt; B</b>",
			"<b>&gt;&gt;=:</b> присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов, равное значению правого операнда: <b>A &gt;&gt;= B</b> эквивалентно <b>A = A &gt;&gt; B</b> \n<b>&amp=:</b> присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением правого операнда: <b>A &amp= B</b> эквивалентно <b>A = A &amp B</b>",
			"<b>|=:</b> присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением правого операнда: <b>A |= B</b> эквивалентно <b>A = A | B</b> \n<b>^=:</b> присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением правого операнда: <b>A ^= B</b> эквивалентно <b>A = A ^ B</b>",
			"Примеры операций: \n<code> int a = 5; \na += 10 // 15 \na -= 3; // 12 \na *= 2; // 24 \na /= 6; // 4 \na &lt;&lt;= 4; // 64 \na &gt;&gt;= 2; // 16</code>"
		]
	},
	
	"conditional_constructions": 
	{
		"name": "Условные конструкции",
		"page_1":
		[
			"Условные конструкции направляют ход программы по одному из возможных путей в зависимости от условия. \n<b>Конструкция if</b> \nКонструкция <b>if</b> проверяет истинность условия, и если оно истинно, выполняет блок инструкций. Этот оператор имеет следующую сокращенную форму:",
			"<code>if (condition) \n{ \nинструкции; \n}</code> \nВ качестве <i>условия</i> использоваться условное выражение, которое возвращает true или false. Если условие возвращает true, то выполняются последующие инструкции, которые входят в блок if. Если условие возвращает false, то последующие инструкции не выполняются. Блок инструкций заключается в фигурные скобки. \nНапример:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint x = 60; \nif(x &gt; 50) \n{ \nstd::cout &lt;&lt; 'x is greater than 50 \n'; \n} \nif(x &lt; 30) \n{ \nstd::cout &lt;&lt; 'x is less than 30 \n'; \n} \nstd::cout &lt;&lt; 'End of Program' &lt;&lt; '\n'; \nreturn 0; \n}",
			"Здесь определены две условных конструкции if. Они проверят больше или меньше значение переменной x, чем определенное значение. В качестве инструкции в обоих случаях выполняется вывод некоторой строки на консоль. \nВ первом случае x &gt; 50 условие истинно, так как значение переменной x действительно больше 50, поэтому это условие возвратит true, и, следовательно, будут выполнятся инструкции, которые входят в блок if.",
			"Во втором случае операция отношения x < 30 возвратит false, так как условие ложно, поэтому последующий блок инструкций выполняться не будет. В итоге при запуске программы вывод консоли будет выглядеть следующим образом: \n<b>x greater than 50 \nEnd of Program</b> \nакже мы можем использовать полную форму конструкции if, которая включает оператор else:",
			"<code>if(condition_expression) \ninstruction_1 \nelse \ninstruction_2</code> \nПосле оператора else мы можем определить набор инструкций, которые выполняются, если условие в операторе if возвращает false. То есть если условие истинно, выполняются инструкции после оператора if, а если это выражение ложно, то выполняются инструкции после оператора else.",
			"<code>int x = 50; \nif(x &gt; 60) \nstd::cout &lt;&lt; 'x is greater than 60 \n'; \nelse \nstd::cout &lt;&lt; 'x is less or equal 60 \n'; \nВ данном случае условие x &gt; 60 ложно, то есть возвращает false, поэтому будет выполняться блок else. И в итоге на консоль будет выведена строка 'x is less or equal 60 \n'.",
			"Однако нередко надо обработать не два возможных альтернативных варианта, а гораздо больше. Например, в случае выше можно насчитать три условия: переменная x может быть больше 60, меньше 60 и равна 60. Для проверки альтернативных условий мы можем вводить выражения <b>else if</b>:",
			"<code>int x = 60; \nif(x &gt; 60) \n{ \nstd::cout &lt;&lt; 'x is greater than 60 \n'; \n} \nelse if (x &lt; 60) \n{ \nstd::cout &lt;&lt; 'x is less than 60 \n'; \n} \nelse \n{ \nstd::cout &lt;&lt; 'x is equal 60 \n'; \nТо есть в данном случае мы получаем три ветки развития событий в программе. \nЕсли в блоке if или else или else-if необходимо выполнить только одну инструкцию, то фигурные скобки можно опустить:",
			"<code>int x = 60; \nif(x &gt; 60) \nstd::cout &lt;&lt; 'x is greater than 60 \n'; \nelse if (x &lt; 60) \nstd::cout &lt;&lt; 'x is less than 60 \n'; \nelse \nstd::cout &lt;&lt; 'x is equal 60 \n'; \n}</code>"
		],
		
		"page_2":
		[
			"<b>Конструкция switch</b> \nДругую форму организации ветвления программ представляет конструкция switch...case. Она имеет следующую форму: \n<code>switch(выражение) \n{ \ncase константа_1: инструкции_1; \ncase константа_2: инструкции_2; \ndefault: инструкции; \n}</code>",
			"После ключевого слова <b>switch</b> в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями после оператора <b>сase</b>. И если совпадение будет найдено, то будет выполняться определенный блок <b>сase</b>. \nВ конце конструкции switch может стоять блок <b>default</b>. Он необязателен и выполняется в том случае, если значение после switch не соответствует ни одному из операторов case. Например:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint x = 2; \nswitch(x) \n{ \ncase 1: \nstd::cout &lt;&lt; 'x = 1' << '\n'; \nbreak; \ncase 2: \nstd::cout &lt;&lt; 'x = 2' &lt;&lt; '\n'; \nbreak; \ncase 3: \nstd::cout &lt;&lt; 'x = 3' &lt;&lt; '\n'; \nbreak; \ndefault: \nstd::cout &lt;&lt; 'x is undefined' &lt;&lt; 'n'; \nbreak; \n \nreturn 0; \n}</code> \nЧтобы избежать выполнения последующих блоков case/default, в конце каждого блока ставится оператор <b>break</b>. То есть в данном случае будет выполняться оператор",
			"<code>case 2: \nstd::cout &lt;&lt; 'x = 2' &lt;&lt; '\n'; \nbreak; \nПосле выполнения оператора break произойдет выход из конструкции switch..case, и остальные операторы case будут проигнорированы. Поэтому на консоль будет выведена следующая строка \n<b>x=2</b> \nСтоит отметить важность использования оператора break. Если мы его не укажем в блоке case, то после этого блока выполнение перейдет к следующему блоку case. Например, уберем из предыдущего примера все операторы break:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint x = 2; \nswitch(x) \n{ \ncase 1: \nstd::cout &lt;&lt; 'x = 1' &lt;&lt; '\n'; \ncase 2: \nstd::cout &lt;&lt; 'x = 2' &lt;&lt; '\n'; \ncase 3: \nstd::cout &lt;&lt; 'x = 3' &lt;&lt; '\n'; \ndefault: \nstd::cout &lt;&lt; 'x is undefined' &llt;&lt; '\n'; \n} \nreturn 0; \n}</code>",
			"В этом случае опять же будет выполняться оператор case 2:, так как переменная x=2. Однако так как этот блок case не завершается оператором break, то после его завершения будет выполняться набор инструкций после case 3: даже несмотря на то, что переменная x по прежнему равна 2. В итоге мы получим следующий консольный вывод: <b>\nx = 2 \nx = 3 \nx is undefined</b>"
		],
		
		"page_3":
		[
			"<b>Тернарный оператор</b> \nТернарный оператор <b>?:</b> позволяет сократить определение простейших условных конструкций if и имеет следующую форму: \n[первый операнд - условие] ? [второй операнд] : [третий операнд]",
			"Оператор использует сразу три операнда. В зависимости от условия тернарный оператор возвращает второй или третий операнд: если условие равно true (то есть истинно), то возвращается второй операнд; если условие равно false (то есть ложно), то третий. Например:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nsetlocale(LC_ALL, ""); \nint x = 5; \nint y = 3; \nchar sign; \nstd::cout &lt;&lt; 'Enter the operation character: '; \nstd::cin &gt;&gt; sign; \nint result = sign=='+'?x + y:x - y; \nstd::cout &lt;&lt; 'Result: ' &lt;&lt; result &lt;&lt; '\n'; \nreturn 0;</codde>",
			"В данном случае производится ввод знака операции. Здесь результатом тернарной операции является переменная result. И если переменная sign содержит знак '+', то result будет равно второму операнду - (x+y). Иначе result будет равно третьему операнду."
		]
	},
	
	"loops": 
	{
		"name": "Циклы",
		"page_1":
		[
			"Для выполнения некоторых действий множество раз в зависимости от определенного условия используются циклы. В языке C++ имеются следующие виды циклов: \n<b>for</b> \n<b>while</b> \n<b>do...while</b>",
			"<b>Цикл while</b> \nЦикл while выполняет некоторый код, пока его условие истинно, то есть возвращает true. Он имеет следующее формальное определение: \n<code>while(условие) \n{ \n// выполняемые действия \n}</code> \nПосле ключевого слова <b>while</b> в скобках идет условное выражение, которое возвращает true или false. Затем в фигурных скобках идет набор инструкций, которые составляют тело цикла. И пока условие возвращает true, будут выполняться инструкции в теле цикла.",
			"Например, выведем квадраты чисел от 1 до 9: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint i = 1; \nwhile(i < 10) \n{ \nstd::cout &lt;&lt; i &lt;&lt; ' * ' &lt;&lt; i &lt;&lt; ' = ' &lt;&lt; i * i &lt;&lt; std::endl; \ni++; \n} \nreturn 0; \n}</code> \nЗдесь пока условие i &lt; 10 истинно, будет выполняться цикл while, в котором выводится на консоль квадрат числа и инкрементируется переменная i. В какой-то момент переменная i увеличится до 10, условие i &lt; 10 возвратит false, и цикл завершится.",
			"Консольный вывод программы: \n<b>1 * 1 = 1 \n2 * 2 = 4 \n3 * 3 = 9 \n4 * 4 = 16 \n5 * 5 = 25 \n6 * 6 = 36 \n7 * 7 = 49 \n8 * 8 = 64 \n9 * 9 = 81</b> \nКаждый отдельный проход цикла называется итерацией. То есть в примере выше было 9 итераций.",
			"Если цикл содержит одну инструкцию, то фигурные скобки можно опустить: \n<code>int i = 0; \nwhile(++i &lt; 10) \nstd::cout &lt;&lt; i &lt;&lt; ' * ' &lt;&lt; i &lt;&lt; ' = ' &lt;&lt; i * i &lt;&lt; std::endl;</code> \n<i>выражение_2</i> представляет условие, при соблюдении которого выполняется цикл. Как правило, в качестве условия используется операция сравнения, и если она возвращает ненулевое значение (то есть условие истинно), то выполняется тело цикла, а затем вычисляется <i>выражение_3</i>. \n<i>выражение_3</i> задает изменение параметров цикла, нередко здесь происходит увеличение счетчиков цикла на единицу."
		],
		
		"page_2":
		[
			"<b>Цикл for</b> \nЦикл for имеет следующее формальное определение: \n<code>for (выражение_1; выражение_2; выражение_3) \n{ \n// тело цикла \n}</code>",
			"<i>выражение_1</i> выполняется один раз при начале выполнения цикла и представляет установку начальных условий, как правило, это инициализация счетчиков - специальных переменных, которые используются для контроля за циклом.",
			"Например, перепишем программу по выводу квадратов чисел с помощью цикла for: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nfor(int i =1; i &lt; 10; i++) \n{ \nstd::cout &lt;&lt; i &lt;&lt; ' * ' &lt;&lt; i &lt;&lt; ' = ' &lt;&lt; i * i &lt;&lt; std::endl; \n} \nreturn 0; \n}</code>",
			"Первая часть объявления цикла - int i = 1 - создает и инициализирует счетчик i. Фактически это то же самое, что и объявление и инициализация переменной. Счетчик необязательно должен представлять тип int. Это может быть и другой числовой тип, например, float. И перед выполнением цикла его значение будет равно 1. \nВторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока переменная i не станет равна 10.",
			"И третья часть - приращение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: i--. Можно изменять на другое значение: i+=2. \nВ итоге блок цикла сработает 9 раз, пока переменная i не станет равна 10. И каждый раз это значение будет увеличиваться на 1. И по сути мы получим тот же самый результат, что и в случае с циклом while: \n<b>1 * 1 = 1 \n2 * 2 = 4 \n3 * 3 = 9 \n4 * 4 = 16 \n5 * 5 = 25 \n6 * 6 = 36 \n7 * 7 = 49 \n8 * 8 = 64 \n9 * 9 = 81</b>",
			"Необязательно указывать все три выражения в определении цикла, мы можем одно или даже все из них опустить: \n<code>int i = 1; \nfor(; i &lt; 10;) \n{ \nstd::cout &lt;&lt; i &lt;&lt; ' * ' &lt;&lt; i &lt;&lt; ' = ' &lt;&lt; i * i &lt;&lt; std::endl; \ni++; \n}</code> \nФормально определение цикла осталось тем же, только теперь первое и третье выражения в определении цикла отсутствуют: for (; i &lt; 10;). Переменная-счетчик определена и инициализирована вне цикла, а ее приращение происходит в самом цикле.",
			"Можно определять вложенные циклы. Например, выведем таблицу умножения: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nfor (int i=1; i &lt; 10; i++) \n{ for(int j = 1; j &lt; 10; j++) \n{ \nstd::cout &lt;&lt; i * j &lt;&lt; '\t'; \n} \nstd::cout &lt;&lt; std::endl; \n} \return 0; \n}</code>"
		],
		
		"page_3":
		[
			"<b>Цикл do</b> \nВ цикле do сначала выполняется код цикла, а потом происходит проверка условия в инструкции while. И пока это условие истинно, то есть не равно 0, то цикл повторяется. Формальное определение цикла:",
			"<code>do \n{ \nинструкции \n} \nwhile(условие);</code> \nНапример: \n#include &lt;iostream&gt; \nint main() \n{ \nint i = 6; \ndo \n{ \nstd::cout &lt;&lt; i &lt;&lt; std::endl; \ni--; \n} \nwhile(i&gt;0); \nreturn 0; \n}</code> \nЗдесь код цикла сработает 6 раз, пока i не станет равным нулю.",
			"Но важно отметить, что цикл do гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции while не будет истинно. То есть мы можем написать:: \n<code>int i = -1; \ndo \n{ \nstd::cout &lt;&lt; i &lt;&lt; std::endl; \ni--; \n} \nwhile(i&gt;0); \n}</code> \nХотя у нас переменная i меньше 0, цикл все равно один раз выполнится."
		],
		
		"page_4":
		[
			"<b>Операторы continue и break</b> \nИногда возникает необходимость выйти из цикла до его завершения. В этом случае можно воспользоваться оператором <b>break</b>. Например:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint i = 1; \nfor ( ; ; ) \n{ \nstd::cout &lt;&lt; i &lt;&lt; ' * ' &lt;&lt; i &lt;&lt; ' = ' <&lt;&lt; i * i &lt;&lt; std::endl; \ni++; \nif (i &gt; 9) break; \n} \nreturn 0; \n}</code>",
			"Здесь когда значение переменной i достигнет 10, осуществляется выход из цикла с помощью оператора break. \nВ отличие от оператора break, оператор continue производит переход к следующей итерации. Например, нам надо посчитать сумму только нечетных чисел из некоторого диапазона:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint result = 0; \nfor (int i=0; i&lt;10; i++) \n{ \nif (i % 2 == 0) continue; \nresult +=i; \n} \nstd::cout &lt;&lt; 'result = ' &lt;&lt; result &lt;&lt; std::endl; // 25 \nreturn 0;</code> \nЧтобы узнать, четное ли число, мы получаем остаток от целочисленного деления на 2, и если он равен 0, то с помощью оператора continue переходим к следующей итерации цикла. А если число нечетное, то складываем его с остальными нечетными числами."
		]		
	},
	
	"links": 
	{
		"name": "Ссылки",
		"page_1":
		[
			"Ссылка (reference) представляет способ манипулировать каким-либо объектом. Фактически ссылка - это альтернативное имя для объекта. Для определения ссылки применяется знак амперсанда &: \n<code>int number = 5; \nint &amprefNumber = number;</code>",
			"В данном случае определена ссылка refNumber, которая ссылается на объект number. При этом в определении ссылки используется тот же тип, который представляет объект, на который ссылка ссылается, то есть в данном случае int. \nПри этом нельзя просто определить ссылку:",
			"<code>int &amprefNumber;</code> \nОна обязательно должна указывать на какой-нибудь объект. \nТакже нельзя присвоить ссылке литеральное значение, например, число: \n<code>int &refNumber = 10;</code> \nПосле установления ссылки мы можем через нее манипулировать самим объектом, на который она ссылается:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint number = 5; \nint &amprefNumber = number; \nstd::cout &lt;&lt; refNumber &lt;&lt; std::endl; // 5 \nrefNumber = 20; \nstd::cout &lt;&lt; number &lt;&lt; std::endl;   // 20 \nreturn 0; \n}</code> \nИзменения по ссылке неизбежно скажутся и на том объекте, на который ссылается ссылка.",
			"Можно определять не только ссылки на переменные, но и ссылки на константы. Но при этом ссылка сама должна быть константной: \n<code>const int number = 5; \nconst int &amprefNumber = number; \nstd::cout &lt;&lt; refNumber &lt;&lt; std::endl; // 5 \n//refNumber = 20; изменять значение по ссылке нельзя</code>",
			"Инициализировать неконстантную ссылку константным объектом мы не можем: \n<code>const int number = 5; \nint &amprefNumber = number; // error</code> \nТакже константная ссылка может указывать и на обычную переменную, только значение по такой ссылке мы не сможем изменить:",
			"<code>int number = 5; \nconst int &amprefNumber = number; \nstd::cout &lt;&lt; refNumber &lt;&lt; std::endl; // 5 \n//refNumber = 20; изменять значение по ссылке на константу нельзя \n// но мы можем изменить саму переменную \nnumber = 20; \nstd::cout &lt;&lt; refNumber &lt;&lt; std::endl; // 20</code>",
			"В данном случае несмотря на то, что мы не можем напрямую изменить значение по константной ссылке, тем не менее мы можем изменить сам объект, что приведет естественно к изменению константной ссылки."
		]	
	},
	
	"arrays": 
	{
		"name": "Массивы",
		"page_1":
		[
			"Массив представляет набор однотипных данных. Формальное определение массива выглядит следующим образом: \n<code>тип_переменной название_массива [длина_массива]</code> \nПосле типа переменной идет название массива, а затем в квадратных скобках его размер. Например, определим массив из 4 чисел: \n<code>int numbers[4];</code>",
			"Данный массив имеет четыре числа, но все эти числа имеют неопределенное значение. Однако мы можем выполнить инициализацию и присвоить этим числам некоторые начальные значения через фигурные скобки: \n<codeint numbers[4] = {1,2,3,4};</code> \nЗначения в фигурных скобках еще называют инициализаторами. Если инициализаторов меньше, чем элементов в массиве, то инициализаторы используются для первых элементов. Если в инициализаторов больше, чем элементов в массиве, то при компиляции возникнет ошибка:",
			"<code>int numbers[4] = {1, 2, 3, 4, 5, 6};</code> \nЗдесь массив имеет размер 4, однако ему передается 6 значений. \nЕсли размер массива не указан явно, то он выводится из количества инициализаторов: \n<code>int numbers[] = {1, 2, 3, 4, 5, 6};</code> \nВ данном случае в массиве есть 6 элементов.",
			"Свои особенности имеет инициализация символьных массивов. Мы можем передать символьному массиву как набор инициализаторов, так и строку: \n<code>char s1[] = {'h', 'e', 'l', 'l', 'o'}; \nchar s2[] = 'world';</code> \nПричем во втором случае массив s2 будет иметь не 5 элементов, а 6, поскольку при инициализации строкой в символьный массив автоматически добавляется нулевой символ '\0'.",
			"При этом не допускается присвоение одному массиву другого массива: \n<code>int nums1[] = {1,2,3,4,5}; \nint nums2[] = nums1; //ошибка \nnums2 = nums1; // ошибка</code> \nПосле определения массива мы можем обратиться к его отдельным элементам по индексу. Индексы начинаются с нуля, поэтому для обращения к первому элементу необходимо использовать индекс 0. Обратившись к элементу по индексу, мы можем получить его значение, либо изменить его:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint numbers[4] = {1,2,3,4}; \nint first_number = numbers[0]; \nstd::cout &lt;&lt; first_number &lt;&lt; std::endl; // 1 \nnumbers[0] = 34; //изменяем элемент \nstd::cout &lt;&lt; numbers[0] &lt;&Lt; std::endl; // 34 \nreturn 0; \n}</code> \nЧисло элементов массива также можно определять через константу: \n<code>const int n = 4; \nint numbers[n] = {1,2,3,4};</code>"
		],
		
		"page_2":
		[
			"<b>Перебор массивов</b> \nИспользуя циклы, можно пробежаться по всему массиву и через индексы обратиться к его элементам: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint numbers[4] = {1,2,3,4}; \nint size = sizeof(numbers)/sizeof(numbers[0]); \nfor(int i=0; i &lt; size; i++) \nstd::cout &lt;&lt; numbers[i] &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Чтобы пройтись по массиву в цикле, вначале надо найти длину массива. Для нахождения длины применяется оператор <b>sizeof</b>. По сути длина массива равна совокупной длине его элементов. Все элементы представляют один и тот же тип и занимают один и тот же размер в памяти. Поэтому с помощью выражения sizeof(numbers) находим длину всего массива в байтах, а с помощью выражения sizeof(numbers[0]) - длину одного элемента в байтах. Разделив два значения, можно получить количество элементов в массиве. А далее с помощью цикла for перебираем все элементы, пока счетчик i не станет равным длине массива. В итоге на консоль будут выведены все элементы массива:",
			"Но также есть и еще одна форма цикла <b>for</b>, которая предназначена специально для работа с коллекциями, в том числе с массивами. Эта форма имеет следующее формальное определение:<b>1 \n2 \n3 \n4</b> \n \n<code>for(тип переменная : коллекция) \n{ \nинструкции; \n}</code> \nИспользуем эту форму для перебора массива:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint numbers[4] = {1,2,3,4}; \nfor(int number : numbers) \nstd::cout &lt;&lt; number &lt;&lt; std::endl; \nreturn 0; \n}</code> \nПри переборе массива каждый перебираемый элемент будет помещаться в переменную number, значение которой в цикле выводится на консоль.",
			"Если нам неизвестен тип объектов в массиве, то мы можем использовать спецификатор auto для определения типа: \n<code>for(auto number : numbers) \nstd::cout &lt;&lt; number &lt;&lt; std::endl;</code>"
		],
		
		"page_3":
		[
			"<b>Многомерные массивы</b> \nКроме одномерных массивов в C++ есть многомерные. Элементы таких массивов сами в свою очередь являются массивами, в которых также элементы могут быть массивами. Например, определим двухмерный массив чисел: \n<code>int numbers[3][2];</code>",
			"Такой массив состоит из трех элементов, при этом каждый элемент представляет массив из двух элементов. Инициализируем подобный массив: \n<code>int numbers[3][2] = { {1, 2}, {4, 5}, {7, 8} };</code> \nВложенные фигурные скобки очерчивают элементы для каждого подмассива. Такой массив еще можно представить в виде таблицы:",
			"1 2\n4 5 \n7 8 \nТакже при инициализации можно опускать фигурные скобки:: \n<code>int numbers[3][2] = { 1, 2, 4, 5, 7, 8 };</code> \nВозможна также инициализация не всех элементов, а только некоторых: \n<code>int numbers[3][2] = { {1, 2}, {}, {7} };</code> \nИ чтобы обратиться к элементам вложенного массива, потребуется два индекса:",
			"<code>int numbers[3][2] = { {1, 2}, {3, 4}, {5, 6} }; \nstd::cout &lt;&lt; numbers[1][0] &lt;&lt; std::endl;    // 3 \nnumbers[1][0] = 12;             // изменение элемента \nstd::cout &lt;&lt; numbers[1][0] &lt;&lt; std::endl;    // 12</code> \nПереберем двухмерный массив:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nconst int rows = 3, columns = 2; \nint numbers[rows][columns] = { {1, 2}, {3, 4}, {5, 6} }; \nfor(int i=0; i < rows; i++) \n{ \nfor(int j=0; j < columns; j++) \n{ \nstd::cout &lt;&lt; numbers[i] [j] &lt;&lt; '\t'; \n} \nstd::cout &lt;&lt; std::endl; \n} \nreturn 0; \n}</code> \nТакже для перебора элементов многомерного массива можно использовать другую форму цикла for:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nconst int rows = 3, columns = 2; \nint numbers[rows][columns] = { {1, 2}, {3, 4}, {5, 6} }; \nfor(auto &subnumbers : numbers) \n{ \nfor(int number : subnumbers) \n{ \nstd::cout &lt;&lt; number &lt;&lt; '\t'; \n} \nstd::cout &lt;&lt; std::endl; \n} \nreturn 0; \n}</code>",
			"Для перебора массивов, которые входят в массив, применяются ссылки. То есть во внешнем цикле for(auto &subnumbers : numbers) &subnumbers представляет ссылку на подмассив в массиве. Во внутреннем цикле for(int number : subnumbers) из каждого подмассива в subnumbers получаем отдельные его элементы в переменную number и выводим ее значение на консоль."
		]	
		
	},
	
	"strings": 
	{
		"name": "Строки"
	}

}
